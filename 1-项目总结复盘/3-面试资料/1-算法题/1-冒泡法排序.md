冒泡排序java
在Java中实现冒泡排序（Bubble Sort）是一种简单直观的排序方法。冒泡排序的基本思想是通过重复遍历要排序的数列，每次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复进行的，直到没有再需要交换的元素为止，这意味着该数列已经排序完成。

以下是一个用Java实现的冒泡排序的示例代码：

    public class BubbleSort {
        public static void bubbleSort(int[] arr) {
        int n = arr.length;
        boolean swapped; // 用于优化，如果某一趟没有发生交换，则说明数组已经排序完成
            for (int i = 0; i < n - 1; i++) {
            swapped = false; // 开始前假定这一趟没有发生交换
                for (int j = 0; j < n - 1 - i; j++) { // 内层循环每次减少一次，因为每趟排序后最后的元素已经是最大的
                    if (arr[j] > arr[j + 1]) {
                        // 交换arr[j]和arr[j + 1]
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                        swapped = true; // 发生了交换
                    }
                }
            // 如果这一趟没有发生交换，说明数组已经有序，可以提前结束排序
            if (!swapped) break;
            }
        }
    
        public static void main(String[] args) {
            int[] arr = {64, 34, 25, 12, 22, 11, 90};
            bubbleSort(arr);
            System.out.println("Sorted array");
            for (int value : arr) {
                System.out.print(value + " ");
            }
        }
    }


代码解释：

外层循环：控制遍历的轮数。每一轮都将未排序的最大元素“冒泡”到它应该在的位置。

内层循环：负责在每一轮中进行实际的比较和交换操作。每次比较相邻的两个元素，如果它们的顺序错误（即前一个元素大于后一个元素），则交换它们。随着每一轮的进行，最大的元素会“冒泡”到它应该在的位置（即数组的末尾）。

优化：swapped变量用于检测每一轮是否发生了交换。如果没有发生交换，说明数组已经有序，可以提前结束排序，提高效率。

main方法：测试冒泡排序的实现，打印排序后的数组。

复杂度分析：

时间复杂度：最好情况下（数组已经有序）为O(n)，最坏情况下（数组完全逆序）为O(n^2)。平均情况下也是O(n^2)。

空间复杂度：O(1)，因为只需要常数级别的额外空间。

虽然冒泡排序的实现简单，但在实际开发中，由于其较低的效率（尤其是在数据量较大时），通常会推荐使用更高效的排序算法如快速排序、归并排序等。不过，了解并掌握冒泡排序对于理解其他复杂排序算法的原理是有帮助的。